.data
A: .word 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
N: .word 10
count: .word 0

.text
.global _start
_start:
    li sp, 0x03FFFFFC

    # Khởi tạo các biến
    la s0, A         # s0 = địa chỉ mảng A
    la s1, N
    lw s1, 0(s1)     # s1 = N (kích thước mảng)
    li s2, 0         # s2 = count (đếm số nguyên tố)
    li s3, 0         # s3 = i (chỉ số hiện tại)

LOOP:
    bge s3, s1, END_LOOP

    slli t0, s3, 2   # t0 = i * 4
    add t0, s0, t0   # t0 = &A[i]
    lw a0, 0(t0)     # a0 = A[i]

    jal ra, isPrime

    beqz a0, SKIP
    addi s2, s2, 1   # count++

SKIP:
    addi s3, s3, 1
    j LOOP

END_LOOP:
    la t0, count
    sw s2, 0(t0)

STOP:
    j STOP


# ====================================
# Hàm kiểm tra nguyên tố không dùng mul/div/rem
# ====================================
isPrime:
    addi sp, sp, -12
    sw ra, 8(sp)
    sw s0, 4(sp)
    sw s1, 0(sp)

    # if a0 < 2 → not prime
    li t0, 2
    blt a0, t0, NOT_PRIME

    # if a0 == 2 → prime
    beq a0, t0, IS_PRIME

    # if a0 % 2 == 0 → not prime
    andi t0, a0, 1
    beqz t0, NOT_PRIME

    mv s0, a0       # s0 = n
    li s1, 3        # s1 = i = 3

CHECK_LOOP:
    # t0 = i*i bằng cộng lặp
    li t0, 0
    li t3, 0
ComputeSquare:
    add t0, t0, s1
    addi t3, t3, 1
    bne t3, s1, ComputeSquare

    bgt t0, s0, IS_PRIME

    # Kiểm tra chia hết bằng phép trừ lặp
    mv t4, s0       # t4 = n
TrySubtract:
    blt t4, s1, NotDivisible
    beq t4, s1, NOT_PRIME
    sub t4, t4, s1
    j TrySubtract

NotDivisible:
    addi s1, s1, 2
    j CHECK_LOOP

IS_PRIME:
    li a0, 1
    j isPrime_EPILOGUE

NOT_PRIME:
    li a0, 0

isPrime_EPILOGUE:
    lw s1, 0(sp)
    lw s0, 4(sp)
    lw ra, 8(sp)
    addi sp, sp, 12
    ret
