.data
N:      .word 10                      # Số phần tử của mảng
array:  .word 2, 4, 5, 6, 7, 9, 11, 13, 15, 17  # Mảng số nguyên
						# 1 cái .word = 4 byte nên addi t1, t1, 4 vd array[0] = 2 (0x10010000) -> array[1] = 4 (0x10010004)

.text
.globl _start
_start:
    la t1, array        # t1 trỏ tới đầu mảng
    li t0, 0            # t0 đếm số nguyên tố
    li t2, 0            # chỉ số i
    lw t3, N            # t3 = N

loop:
    beq t2, t3, end     # nếu i == N thì kết thúc

    lw a0, 0(t1)        # a0 = array[i]
    jal ra, is_prime    # gọi hàm kiểm tra số nguyên tố -> trả ra a0 = 0 hoặc a0 = 1
    beq a0, zero, skip  # nếu không phải số nguyên tố thì bỏ qua
                        # a0 = 1 thì tang gia tri t0 / a0 = 0 thì đến skip
    addi t0, t0, 1      # t0++

skip:
    addi t2, t2, 1      # i++
    addi t1, t1, 4      # dịch con trỏ sang phần tử tiếp theo
    j loop

end:
    # t0 chứa kết quả (số lượng số nguyên tố)
    # kết thúc chương trình
    li a7, 10
    ecall

# Hàm is_prime:
# Input: a0 = số cần kiểm tra
# Output: a0 = 1 nếu là số nguyên tố, 0 nếu không

is_prime:
    li t4, 2		   # Số nguyên tố là những số tự nhiên lớn hơn 1, chỉ có hai ước số là 1 và chính nó
    blt a0, t4, not_prime  # nếu n < 2 -> không phải số nguyên tố -> nhảy xuống not_prime (blt : nhay neu nho hon)
                           
    mv t5, t4              # t5 = i = 2
    sqrt_loop:
        mul t6, t5, t5     # t6 = 2 * 2 = 4
        bgt t6, a0, prime  # 4 > 4 ? → sai → tiếp tục

        rem t6, a0, t5     # t6 = 4 % 2 = 0 (rem : lưu phần dư của phép chia vào thanh ghi t6)
        beq t6, zero, not_prime  # 0 == 0 ? → nhảy đến not_prime 

        addi t5, t5, 1     # i++ (vd a0 = 9 => 4 > 9 sai => 9%2 = 1 sai => addi i + 1 = 3 tiep tuc)
        j sqrt_loop

prime:
    li a0, 1
    ret (ve lai jal)

not_prime:
    li a0, 0
    ret (ve lai jal)
